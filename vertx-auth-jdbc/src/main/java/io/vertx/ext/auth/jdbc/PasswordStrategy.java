/*
 * Copyright 2014 Red Hat, Inc.
 *
 *  All rights reserved. This program and the accompanying materials
 *  are made available under the terms of the Eclipse Public License v1.0
 *  and Apache License v2.0 which accompanies this distribution.
 *
 *  The Eclipse Public License is available at
 *  http://www.eclipse.org/legal/epl-v10.html
 *
 *  The Apache License v2.0 is available at
 *  http://www.opensource.org/licenses/apache2.0.php
 *
 *  You may elect to redistribute this code under either of these licenses.
 */

package io.vertx.ext.auth.jdbc;

import java.nio.charset.StandardCharsets;
import java.util.Base64;
import java.util.Objects;
import java.util.Optional;

import io.vertx.core.json.JsonArray;
import io.vertx.ext.auth.jdbc.impl.SaltedHashPasswordStrategy;

/**
 * Defines the base contract for the password computation strategies that are implemented in
 * order to properly adapt to different mechanisms and systems that authenticate/generate
 * password in different ways.
 *
 * This contract also provides a default implementation for the encoding of the byte data
 * generated by the strategies in order to textually represent them. By default Base64 is used,
 * which is more compact then hexadecimal.
 *
 * @author <a href="http://tfox.org">Tim Fox</a>
 * @author david
 */
public interface PasswordStrategy {

  /**
   * Creates a default hash strategy with the specified algorithm based on the available security
   * providers, following the Java Cryptography Architecture (JCA). The preferred provider will
   * be used when multiple provider are available for the same algorithm.
   *
   * @param algorithm the algorithm
   * @return a new instance of the hash strategy if the algorithm is supported, none if it's not.
   */
  static Optional<PasswordStrategy> create(final String algorithm) {
    Objects.requireNonNull(algorithm, "algorithm");
    final SaltedHashPasswordStrategy strategy = new SaltedHashPasswordStrategy(algorithm);
    return strategy.isSupported() ? Optional.of(strategy) : Optional.empty();
  }

  /**
   * Converts the given byte array to a textual representation.
   * By default Base64 is used to represent the data.
   *
   * @param data the byte array data
   * @return the textual representation of the data
   */
  default String encode(final byte[] data) {
    return new String(Base64.getEncoder().encode(data), StandardCharsets.UTF_8);
  }

  /**
   * Applies the defined hashing strategy to the given password in its plaintext form and a
   * salt (nonce) value and computes a key (hashed password)
   *
   * @param password the password to derive a key from
   * @param salt     the salt to be used in the computation
   * @return the hashed password
   */
  String compute(final String password, final Optional<String> salt);

  /**
   * Retrieves the hashed password from the row data of the authentication query
   *
   * @param row the row data
   * @return the hashed password
   */
  String getPasswordFromQueryResult(final JsonArray row);

  /**
   * Retrieve the salt from the row data of the authentication query, if salts are supported
   * by the implementation.
   *
   * @param row the row data
   * @return the salt, if any
   */
  Optional<String> getSaltFromQueryResult(final JsonArray row);
}
