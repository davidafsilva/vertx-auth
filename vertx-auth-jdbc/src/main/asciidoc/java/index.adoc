== JDBC Auth Provider implementation

We provide an implementation of `link:../../apidocs/io/vertx/ext/auth/AuthProvider.html[AuthProvider]` which uses the Vert.x `link:../../apidocs/io/vertx/ext/jdbc/JDBCClient.html[JDBCClient]`
to perform authentication and authorisation against any JDBC compliant database.

To use this project,
add the following dependency to the _dependencies_ section of your build descriptor:

* Maven (in your `pom.xml`):

[source,xml,subs="+attributes"]
----
<dependency>
  <groupId>io.vertx</groupId>
  <artifactId>vertx-auth-jdbc</artifactId>
  <version>3.3.0-SNAPSHOT</version>
</dependency>
----

* Gradle (in your `build.gradle` file):

[source,groovy,subs="+attributes"]
----
compile 'io.vertx:vertx-auth-jdbc:3.3.0-SNAPSHOT'
----

To create an instance you first need an instance of `link:../../apidocs/io/vertx/ext/jdbc/JDBCClient.html[JDBCClient]`. To learn how to create one
of those please consult the documentation for the JDBC client.

Once you've got one of those you can create a `link:../../apidocs/io/vertx/ext/auth/jdbc/JDBCAuth.html[JDBCAuth]` instance as follows:

[source,java]
----
JDBCClient jdbcClient = JDBCClient.createShared(vertx, jdbcClientConfig);

JDBCAuth authProvider = JDBCAuth.create(jdbcClient);
----

Once you've got your instance you can authenticate and authorise with it just like any `link:../../apidocs/io/vertx/ext/auth/AuthProvider.html[AuthProvider]`.

The out of the box config assumes certain queries for authentication and authorisation, these can easily be changed
with the operations `link:../../apidocs/io/vertx/ext/auth/jdbc/JDBCAuth.html#setAuthenticationQuery-java.lang.String-[setAuthenticationQuery]`,
`link:../../apidocs/io/vertx/ext/auth/jdbc/JDBCAuth.html#setPermissionsQuery-java.lang.String-[setPermissionsQuery]` and
`link:../../apidocs/io/vertx/ext/auth/jdbc/JDBCAuth.html#setRolesQuery-java.lang.String-[setRolesQuery]`, if you want to use them with a different
database schema.

The default implementation assumes that the password is stored in the database as a SHA-512 hash.
Salts are also supported, if provided/available they're added to the digest pior to hashing the
password. It also assumes that the salt is stored in the table too along with the password hash.

Vert.x supports both message digest and message authentication code algorithms that are
available through JCA security providers, along with BCrypt support (relies on `link:http://www.mindrot.org/projects/jBCrypt/[jBCrypt]`).
To create any of the above mentioned strategies, simply use the available static factory method via
`link:../../apidocs/io/vertx/ext/auth/jdbc/PasswordStrategy.html#create-java.lang.String-[create]` and specify the desired algorithm.

Additionally, you can also specify a `link:../../apidocs/io/vertx/ext/auth/jdbc/PasswordEncoder.html[password encoder]`, which will encode
the output of the digest/mac functions with the specified implementation. We provide support for both
Hexadecimal and Base64 encoders, the latter being the default.

Any of the built-in or your own alternative password strategy implementations can be provided and used by setting it
with `link:../../apidocs/io/vertx/ext/auth/jdbc/JDBCAuth.html#setPasswordStrategy-io.vertx.ext.auth.jdbc.PasswordStrategy-[setPasswordStrategy]`.

WARNING: It is advised to never store your passwords as plaintext at your database/tables. Instead, you
should always use some solid, strong and proven hashing technique/algorithm, such as PBKDF (as BCrypt),
HMAC (as HMAC-SHA512) or an hashing algorithm (as SHA-512) together with a salt. The latter should always
be used with a salt, without it your data is more vulnerable to several attack vectors, such as brute-force and rainbow table attacks.

== Authentication

When authenticating using this implementation, it assumes `username` and `password` fields are present in the
authentication info:

[source,java]
----
JsonObject authInfo = new JsonObject().put("username", "tim").put("password", "sausages");

authProvider.authenticate(authInfo, res -> {
  if (res.succeeded()) {
    User user = res.result();
  } else {
    // Failed!
  }
});
----

== Authorisation - Permission-Role Model

Although Vert.x auth itself does not mandate any specific model of permissions (they are just opaque strings), this
implementation assumes a familiar user/role/permission model, where a user can have zero or more roles and a role
can have zero or more permissions.

If validating if a user has a particular permission simply pass the permission into.
`link:../../apidocs/io/vertx/ext/auth/User.html#isAuthorised-java.lang.String-io.vertx.core.Handler-[isAuthorised]` as follows:

[source,java]
----
user.isAuthorised("commit_code", res -> {
  if (res.succeeded()) {
    boolean hasPermission = res.result();
  } else {
    // Failed to
  }
});
----

If validating that a user has a particular _role_ then you should prefix the argument with the role prefix.

[source,java]
----
user.isAuthorised("role:manager", res -> {
  if (res.succeeded()) {
    boolean hasRole = res.result();
  } else {
    // Failed to
  }
});
----

The default role prefix is `role:`. You can change this with `link:../../apidocs/io/vertx/ext/auth/jdbc/JDBCAuth.html#setRolePrefix-java.lang.String-[setRolePrefix]`.
<a href="mailto:julien@julienviet.com">Julien Viet</a><a href="http://tfox.org">Tim Fox</a>
